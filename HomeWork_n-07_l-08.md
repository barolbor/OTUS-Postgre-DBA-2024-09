# Домашнее задание
## Механизм блокировок
 
Настроим сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. За это отвечают следующие параметры конфигурации:

||||
|-|-|-|
|log_lock_waits|boolean|Определяет, нужно ли фиксировать в журнале события, когда сеанс ожидает получения блокировки дольше, чем указано в deadlock_timeout;|
|deadlock_timeout|integer|Время ожидания блокировки, по истечении которого будет выполняться проверка состояния взаимоблокировки. Если это значение задаётся без единиц измерения, оно считается заданным в миллисекундах. Когда включён параметр log_lock_waits, данный параметр также определяет, спустя какое время в журнал сервера будут записываться сообщения об ожидании блокировки.|

```sql
-- Текущие значения параметров
SELECT name, setting FROM pg_settings WHERE name IN ('log_lock_waits', 'deadlock_timeout');
       name       | setting
------------------+---------
 deadlock_timeout | 1000
 log_lock_waits   | off
(2 rows)

-- Установим требуемые
ALTER SYSTEM SET log_lock_waits = on;
ALTER SYSTEM

ALTER SYSTEM SET deadlock_timeout TO 200;
ALTER SYSTEM

-- Перезагрузим файлы конфигурации
SELECT pg_reload_conf();
 pg_reload_conf
----------------
 t
(1 row)

-- Проверим
postgres=# SELECT name, setting FROM pg_settings WHERE name IN ('log_lock_waits', 'deadlock_timeout');
       name       | setting
------------------+---------
 deadlock_timeout | 200
 log_lock_waits   | on
(2 rows)

-- Создадим тестовую таблицу и наполним ее данными
CREATE TABLE accounts(
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    client text,
    amount numeric);
CREATE TABLE

INSERT INTO accounts(id, client, amount)
    VALUES (1,'alice',100.00),
    (2,'bob',200.00),
    (3,'charlie',300.00);
INSERT 0 3    
```
Воспроизведем ситуацию, при которой в журнале появятся такие сообщения.

```sql
-- 1ый сеанс, начнем первую транзакцию и обновим строку
BEGIN;
BEGIN

UPDATE accounts SET amount = amount+100 WHERE id=1;
UPDATE 1

--2ой сеанс, начинаем вторую транзакцию и пытаемся обновить ту же строку
BEGIN;
BEGIN

UPDATE accounts SET amount = amount+300 WHERE id=1;
-- Транзакция подвисает в ожидании блокировки:

-- 1ый сеанс, первая транзакция завершается
COMMIT;
COMMIT

--2ой сеанс, команда успешно завершается. Так же завершим транзакцию
UPDATE 1
 COMMIT;
COMMIT
```
Содержимое журнала

```bash
sudo tail -n 30 /var/log/postgresql/postgresql-16-main.log
...
2025-01-28 21:44:16.320 MSK [2666] postgres@testlock LOG:  process 2666 still waiting for ShareLock on transaction 746 after 200.897 ms
2025-01-28 21:44:16.320 MSK [2666] postgres@testlock DETAIL:  Process holding the lock: 2594. Wait queue: 2666.
2025-01-28 21:44:16.320 MSK [2666] postgres@testlock CONTEXT:  while updating tuple (0,1) in relation "accounts"
2025-01-28 21:44:16.320 MSK [2666] postgres@testlock STATEMENT:  UPDATE accounts SET amount = amount+300 WHERE id=1;
2025-01-28 21:44:37.026 MSK [2666] postgres@testlock LOG:  process 2666 acquired ShareLock on transaction 746 after 20907.364 ms
2025-01-28 21:44:37.026 MSK [2666] postgres@testlock CONTEXT:  while updating tuple (0,1) in relation "accounts"
2025-01-28 21:44:37.026 MSK [2666] postgres@testlock STATEMENT:  UPDATE accounts SET amount = amount+300 WHERE id=1;
2025-01-28 21:45:17.661 MSK [2416] LOG:  checkpoint starting: time
2025-01-28 21:45:17.773 MSK [2416] LOG:  checkpoint complete: wrote 2 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.103 s, sync=0.003 s, total=0.112 s; sync files=2, longest=0.002 s, average=0.002 s; distance=0 kB, estimate=3164 kB; lsn=0/19B0CA0, redo lsn=0/19B0C68
```

В журнале мы видим, что, по прошествию 200мс, процесс 2666 все еще ожидает получения разделяемой блокировки ShareLock от транзакции 746. Процесс, удерживающий блокировку: 2594. В очереди ожидания только один процесс: 2666. ... Процесс 2666 получил разделяемую блокировку ShareLock от транзакции 746 прождав 20907мс., но на самом деле, не смотря на такую запись в журнале, процесс 2666 не получил и никогда не сможет получить запрошенный режим блокировки ShareLock от транзакции 746, т.к. транзакция с момента ее создания и до окончания удерживает исключительную блокировку ExclusiveLock своего номера, процесс просто встает в очередь и засыпает, по завершению транзакции блокировка снимается, процесс пробуждается, но получить запрошенную блокировку он не может - ресурс (транзакция) уже исчез, но это и не требутся.

*****

Создадим представление, которое показывает информацию компактно и оставляет только блокировки, относящиеся к таблице accounts и к самой транзакции, но без блокировки виртуальных номеров:

```sql
CREATE VIEW locks_accounts AS
    SELECT  
        pid,
        locktype,
        CASE locktype
            WHEN 'relation' THEN relation::regclass::text
            WHEN 'transactionid' THEN transactionid::text
            WHEN 'tuple' THEN relation::regclass||'('||page||','||tuple||')'
        END AS lockid,
        mode,
        granted
    FROM 
        pg_locks
    WHERE 
        locktype in ('relation','transactionid','tuple')
        AND (locktype != 'relation' OR relation = 'accounts'::regclass)
    ORDER BY 
        1, 2, 3;
CREATE VIEW
```

Создадим представление для просмотра информационных битов в заголовках строк таблицы accounts (версия строки, ссылка на следующую версию строки, xmin, xmax, флаги)

```sql
CREATE EXTENSION pageinspect;
CREATE EXTENSION

CREATE OR REPLACE VIEW heap_accounts AS
	SELECT 
        '(0,'||lp||')' AS ctid,
        t_ctid, 
        t_xmin, 
        t_xmax, 
        raw_flags, 
        combined_flags
    FROM 
        heap_page_items(get_raw_page('accounts', 0)),
        LATERAL heap_tuple_infomask_flags(t_infomask, t_infomask2)
    WHERE 
        t_infomask IS NOT NULL OR t_infomask2 IS NOT NULL
    ORDER BY 1;
```

Представление с расшифровкой флагов

```sql
CREATE OR REPLACE VIEW heap_accounts_det AS
	SELECT 
        '(0,'||lp||')' AS ctid,
        CASE lp_flags
            WHEN 0 THEN 'unused'
            WHEN 1 THEN 'normal'
            WHEN 2 THEN 'redirect to '||lp_off
            WHEN 3 THEN 'dead'
        END AS state,
        t_ctid,
        t_xmin || CASE
            WHEN (t_infomask & 256) > 0 THEN ' c'
            WHEN (t_infomask & 512) > 0 THEN ' a'
            ELSE ''
        END AS xmin,
        t_xmax || CASE
            WHEN (t_infomask & 1024) > 0 THEN ' c'
            WHEN (t_infomask & 2048) > 0 THEN ' a'
            ELSE ''
        END AS xmax,
        CASE WHEN t_infomask & 4096 = 4096 THEN 't' END AS is_multi,   --xmax_is_multi,HEAP_XMAX_IS_MULTI 0x1000 t_xmax is a MultiXactId
        CASE WHEN t_infomask & 8192 = 8192 THEN 't' END AS is_upd_ver, --HEAP_UPDATED 0x2000 this is UPDATEd version of row
        CASE WHEN t_infomask2 & 8192 = 8192 THEN 't' END AS keys_upd,  --keys_updated, HEAP_KEYS_UPDATED 0x2000 tuple was updated and key cols modified, or tuple deleted 
        CASE WHEN t_infomask &  128 =  128 THEN 't' END AS lock_only,  --xmax_lock_only, НЕAP_XMAX_LOCK_ONLY 0x0080 xmax, if valid, is only a locker
        CASE WHEN t_infomask & 16 = 16 THEN 't' END AS key_shr,        --HEAP_XMAX_KEYSHR_LOCK 0x0010 xmax is a key-shared locker
        CASE WHEN t_infomask & 64 = 64 THEN 't' END AS exclusive,      --HEAP_XMAX_EXCL_LOCK 0x0040 xmax is exclusive locker
        CASE WHEN t_infomask & 16+64 = 16+64 THEN 't' END AS shared    --HEAP_XMAX_SHR_LOCK (HEAP_XMAX_EXCL_LOCK | HEAP_XMAX_KEYSHR_LOCK) xmax is a shared locker
    FROM 
        heap_page_items(get_raw_page('accounts', 0)),
        LATERAL heap_tuple_infomask_flags(t_infomask, t_infomask2)
    WHERE 
        t_infomask IS NOT NULL OR t_infomask2 IS NOT NULL
    ORDER BY 1;
```

 Функция, если вдруг придется заглянуть на другую страницу или таблицу

```sql
CREATE OR REPLACE FUNCTION heap_detail(relname text, pageno integer)
RETURNS TABLE(
    ctid tid, state text, t_ctid tid, xmin text, xmax text,
    xmin_c text, xmin_a text, xmax_c text, xmax_a text, is_multi text, is_upd_ver text,
    keys_upd text, lock_only text, key_shr text, exclusive text, shared text
) AS $$
    SELECT
        (pageno,lp)::text::tid,
        CASE lp_flags
            WHEN 0 THEN 'unused'
            WHEN 1 THEN 'normal'
            WHEN 2 THEN 'redirect to '||lp_off
            WHEN 3 THEN 'dead'
        END AS state,    
        t_ctid,
        t_xmin,
        t_xmax,
        CASE WHEN t_infomask &  256 =  256 THEN 't' END,  --xmin_commited
        CASE WHEN t_infomask &  512 =  512 THEN 't' END,  --xmin_aborted
        CASE WHEN t_infomask & 1024 = 1024 THEN 't' END,  --xmax_commited
        CASE WHEN t_infomask & 2048 = 2048 THEN 't' END,  --xmax_aborted
        CASE WHEN t_infomask & 4096 = 4096 THEN 't' END,  --xmax_is_multi
        CASE WHEN t_infomask & 8192 = 8192 THEN 't' END,  --this is UPDATEd version of row
        CASE WHEN t_infomask2 & 8192 = 8192 THEN 't' END, --keys_updated 
        CASE WHEN t_infomask &  128 =  128 THEN 't' END,  --xmax_lock_only        
        CASE WHEN t_infomask & 16 = 16 THEN 't' END,      --xmax is a key-shared locker
        CASE WHEN t_infomask & 64 = 64 THEN 't' END,      --xmax is exclusive locker
        CASE WHEN t_infomask & 16+64 = 16+64 THEN 't' END --xmax is a shared locker
        FROM
            heap_page_items(get_raw_page(relname,pageno))
        ORDER BY lp;
$$ LANGUAGE sql;
```

Перезальем заново таблицу accounts

```sql
TRUNCATE TABLE accounts;
-- чтобы xmin были разные, каждая вставка отдельной командой
INSERT INTO accounts(id, client, amount) VALUES (1,'alice',100.00);
INSERT INTO accounts(id, client, amount) VALUES (2,'bob',200.00);
INSERT INTO accounts(id, client, amount) VALUES (3,'charlie',300.00);
-- сделаем select для простановки бита xmin committed
SELECT * FROM accounts;
```

Смоделируем ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах, и изучим возникшие блокировки.

Из-за того, что блокировка строки — просто признак, очередь организована весьма нетривиально. Когда транзакция собирается изменить строку, она выполняет следующую последовательность действий:
1. если поле xmax и информационные биты версии строки указывают на то, что строка заблокирована в несовместимом режиме, захватывает исключительную тяжелую блокировку изменяемой версии строки;
2. при необходимости дожидается освобождения несовместимых блокировок, запрашивая блокировку номера транзакции xmax (или нескольких транзакций, если xmax — мультитранзакция);
3. прописывает в версию строки свой номер (в поле xmax) и устанавливает необходимые информационные биты;
4. освобождает блокировку версии строки, если она захватывалась в п. 1.

Заглянем под капот содержимого таблицы accounts

```sql
SELECT * FROM heap_accounts;
 ctid  | t_ctid | t_xmin | t_xmax |                        raw_flags                         | combined_flags
-------+--------+--------+--------+----------------------------------------------------------+----------------
 (0,1) | (0,1)  |    824 |      0 | {HEAP_HASVARWIDTH,HEAP_XMIN_COMMITTED,HEAP_XMAX_INVALID} | {}
 (0,2) | (0,2)  |    825 |      0 | {HEAP_HASVARWIDTH,HEAP_XMIN_COMMITTED,HEAP_XMAX_INVALID} | {}
 (0,3) | (0,3)  |    826 |      0 | {HEAP_HASVARWIDTH,HEAP_XMIN_COMMITTED,HEAP_XMAX_INVALID} | {}
(3 rows)

 SELECT * FROM heap_accounts_det;
 ctid  | state  | t_ctid | xmin  | xmax | is_multi | is_upd_ver | keys_upd | lock_only | key_shr | exclusive | shared
-------+--------+--------+-------+------+----------+------------+----------+-----------+---------+-----------+--------
 (0,1) | normal | (0,1)  | 824 c | 0 a  |          |            |          |           |         |           |
 (0,2) | normal | (0,2)  | 825 c | 0 a  |          |            |          |           |         |           |
 (0,3) | normal | (0,3)  | 826 c | 0 a  |          |            |          |           |         |           |
(3 rows)
```

Приступим к моделированию

```sql
-- 1ый Сеанс. Начнем первую транзакцию и получим id 1ой транзакции и 1-го сеанса

BEGIN;
SELECT pg_current_xact_id(), pg_backend_pid();
 pg_current_xact_id | pg_backend_pid
--------------------+----------------
                830 |           1561
(1 row)

--  Обновим строку:
UPDATE accounts SET amount = amount+200 WHERE id=1;
UPDATE 1

-- Посмотрим блокировки (сеанс 4)

SELECT * FROM locks_accounts WHERE pid = 1561;
 pid  |   locktype    |  lockid  |       mode       | granted
------+---------------+----------+------------------+---------
 1561 | relation      | accounts | RowExclusiveLock | t
 1561 | transactionid | 830      | ExclusiveLock    | t
(2 rows)

-- И что под капотом  (сеанс 4)
SELECT * FROM heap_accounts;
 ctid  | t_ctid | t_xmin | t_xmax |                             raw_flags                             | combined_flags
-------+--------+--------+--------+-------------------------------------------------------------------+----------------
 (0,1) | (0,4)  |    824 |    830 | {HEAP_HASVARWIDTH,HEAP_XMIN_COMMITTED,HEAP_HOT_UPDATED}           | {}
 (0,2) | (0,2)  |    825 |      0 | {HEAP_HASVARWIDTH,HEAP_XMIN_COMMITTED,HEAP_XMAX_INVALID}          | {}
 (0,3) | (0,3)  |    826 |      0 | {HEAP_HASVARWIDTH,HEAP_XMIN_COMMITTED,HEAP_XMAX_INVALID}          | {}
 (0,4) | (0,4)  |    830 |      0 | {HEAP_HASVARWIDTH,HEAP_XMAX_INVALID,HEAP_UPDATED,HEAP_ONLY_TUPLE} | {}
(4 rows)

SELECT * FROM heap_accounts_det;
 ctid  | state  | t_ctid | xmin  | xmax | is_multi | is_upd_ver | keys_upd | lock_only | key_shr | exclusive | shared
-------+--------+--------+-------+------+----------+------------+----------+-----------+---------+-----------+--------
 (0,1) | normal | (0,4)  | 824 c | 830  |          |            |          |           |         |           |
 (0,2) | normal | (0,2)  | 825 c | 0 a  |          |            |          |           |         |           |
 (0,3) | normal | (0,3)  | 826 c | 0 a  |          |            |          |           |         |           |
 (0,4) | normal | (0,4)  | 830   | 0 a  |          | t          |          |           |         |           |
(4 rows)
```

1я транзакция успешно выполняет все четыре шага последовательности и теперь удерживает блокировку таблицы RowExclusiveLock и собственного номера ExclusiveLock. Создала новую версию строки, записав в xmin свой номер, установив флаги HEAP_XMAX_INVALID,HEAP_UPDATED,HEAP_ONLY_TUPLE. Обновила информацию в старой версии строки: записала свой номер в xmax, сняла флаг HEAP_XMAX_INVALID, записала новую версию в t_ctid и установила флаг HEAP_HOT_UPDATED.

```sql
--2ой сеанс. Начинаем вторую транзакцию и получим id 2ой транзакции и 2-го сеанса

BEGIN;
SELECT pg_current_xact_id(), pg_backend_pid();
 pg_current_xact_id | pg_backend_pid
--------------------+----------------
                831 |           1562
(1 row)

-- Пытаемся обновить ту же строку.

UPDATE accounts SET amount = amount+400 WHERE id=1;

--Транзакция подвисает в ожидании блокировки:

-- Посмотрим блокировки (сеанс 4)

SELECT * FROM locks_accounts WHERE pid = 1562;
 pid  |   locktype    |    lockid     |       mode       | granted
------+---------------+---------------+------------------+---------
 1562 | relation      | accounts      | RowExclusiveLock | t
 1562 | transactionid | 830           | ShareLock        | f
 1562 | transactionid | 831           | ExclusiveLock    | t
 1562 | tuple         | accounts(0,1) | ExclusiveLock    | t
(4 rows)

-- И что под капотом (сеанс 4), а тут ничего не изменилось, все в том же состоянии, что и после 1ой транзакции, 2я транзакция до сюда не дошла
SELECT * FROM heap_accounts;
 ctid  | t_ctid | t_xmin | t_xmax |                             raw_flags                             | combined_flags
-------+--------+--------+--------+-------------------------------------------------------------------+----------------
 (0,1) | (0,4)  |    824 |    830 | {HEAP_HASVARWIDTH,HEAP_XMIN_COMMITTED,HEAP_HOT_UPDATED}           | {}
 (0,2) | (0,2)  |    825 |      0 | {HEAP_HASVARWIDTH,HEAP_XMIN_COMMITTED,HEAP_XMAX_INVALID}          | {}
 (0,3) | (0,3)  |    826 |      0 | {HEAP_HASVARWIDTH,HEAP_XMIN_COMMITTED,HEAP_XMAX_INVALID}          | {}
 (0,4) | (0,4)  |    830 |      0 | {HEAP_HASVARWIDTH,HEAP_XMAX_INVALID,HEAP_UPDATED,HEAP_ONLY_TUPLE} | {}
(4 rows)

SELECT * FROM heap_accounts_det;
 ctid  | state  | t_ctid | xmin  | xmax | is_multi | is_upd_ver | keys_upd | lock_only | key_shr | exclusive | shared
-------+--------+--------+-------+------+----------+------------+----------+-----------+---------+-----------+--------
 (0,1) | normal | (0,4)  | 824 c | 830  |          |            |          |           |         |           |
 (0,2) | normal | (0,2)  | 825 c | 0 a  |          |            |          |           |         |           |
 (0,3) | normal | (0,3)  | 826 c | 0 a  |          |            |          |           |         |           |
 (0,4) | normal | (0,4)  | 830   | 0 a  |          | t          |          |           |         |           |
(4 rows)
```

Вторая транзакция дошла только до второго шага. Поэтому, помимо блокировки таблицы accounts в режиме RowExclusiveLock и собственного номера 831 в режиме ExclusiveLock, она добавляет в pg_locks еще две строки: захваченную на первом шаге тяжелую блокировку изменяемой версии строки accounts(0,1) типа tuple в режиме ExclusiveLock и запрошенную на втором шаге блокировку номера первой транзакции 830 в режиме ShareLock.

Поле xmax в обновляемой строке ctid=(0,1) содержит номер первой транзакции t_xmax=830 и не установлен/сброшен флаг HEAP_XMAX_INVALID, не установлен флаг HEAP_XMAX_COMMITTED (??? какие информационные биты версии строки указывают на то, что строка заблокирована в несовместимом режиме ??? я не нашел, наверное это не в инфомасках или определяется по другим совокупным признакам). 

>[!NOTE]
>В PostgreSQL информация о том, что строка заблокирована, хранится только в заголовке версии строки. Фактически это просто признаки в страницах данных, а не настоящие блокировки — в оперативной памяти они никак не отражаются.
>
>Обычно строка блокируется при изменении или удалении. В обоих случаях актуальная версия строки помечается как удаленная. Признаком служит номер транзакции в поле xmax, и этот же номер (в сочетании с дополнительными информационными битами) указывает на то, что строка заблокирована. Когда какая-либо транзакция собирается изменить строку, но видит в поле xmax актуальной версии номер незавершенной транзакции, она обязана дождаться ее завершения. После этого все блокировки будут сняты, и ожидающая транзакция сможет продолжить свою операцию над строкой.

Из выше сказанного следует, что, признаком блокировки строки является наличии в поле xmax номера не завершенной транзакции. В строке ctid=(0,1) xmax=830, транзакция 830 не завершена (статус in progress), и удерживает исключительную блокировку своего номера ExclusiveLock.

```c
/* source:     postgres/src/include/access/htup_details.h */
/*
 * information stored in t_infomask:
 */
#define HEAP_HASNULL			0x0001	/* has null attribute(s) */
#define HEAP_HASVARWIDTH		0x0002	/* has variable-width attribute(s) */
#define HEAP_HASEXTERNAL		0x0004	/* has external stored attribute(s) */
#define HEAP_HASOID_OLD			0x0008	/* has an object-id field */
#define HEAP_XMAX_KEYSHR_LOCK	0x0010	/* xmax is a key-shared locker */
#define HEAP_COMBOCID			0x0020	/* t_cid is a combo CID */
#define HEAP_XMAX_EXCL_LOCK		0x0040	/* xmax is exclusive locker */
#define HEAP_XMAX_LOCK_ONLY		0x0080	/* xmax, if valid, is only a locker */

 /* xmax is a shared locker */
#define HEAP_XMAX_SHR_LOCK	(HEAP_XMAX_EXCL_LOCK | HEAP_XMAX_KEYSHR_LOCK)

#define HEAP_LOCK_MASK	(HEAP_XMAX_SHR_LOCK | HEAP_XMAX_EXCL_LOCK | HEAP_XMAX_KEYSHR_LOCK)
#define HEAP_XMIN_COMMITTED		0x0100	/* t_xmin committed */
#define HEAP_XMIN_INVALID		0x0200	/* t_xmin invalid/aborted */
#define HEAP_XMIN_FROZEN		(HEAP_XMIN_COMMITTED|HEAP_XMIN_INVALID)
#define HEAP_XMAX_COMMITTED		0x0400	/* t_xmax committed */
#define HEAP_XMAX_INVALID		0x0800	/* t_xmax invalid/aborted */
#define HEAP_XMAX_IS_MULTI		0x1000	/* t_xmax is a MultiXactId */
#define HEAP_UPDATED			0x2000	/* this is UPDATEd version of row */
#define HEAP_MOVED_OFF			0x4000	/* moved to another place by pre-9.0
										 * VACUUM FULL; kept for binary
										 * upgrade support */
#define HEAP_MOVED_IN			0x8000	/* moved from another place by pre-9.0
										 * VACUUM FULL; kept for binary
										 * upgrade support */
#define HEAP_MOVED (HEAP_MOVED_OFF | HEAP_MOVED_IN)

#define HEAP_XACT_MASK			0xFFF0	/* visibility-related bits */

/*
 * information stored in t_infomask2:
 */
#define HEAP_NATTS_MASK			0x07FF	/* 11 bits for number of attributes */
/* bits 0x1800 are available */
#define HEAP_KEYS_UPDATED		0x2000	/* tuple was updated and key cols
										 * modified, or tuple deleted */
#define HEAP_HOT_UPDATED		0x4000	/* tuple was HOT-updated */
#define HEAP_ONLY_TUPLE			0x8000	/* this is heap-only tuple */

#define HEAP2_XACT_MASK			0xE000	/* visibility-related bits */

/*
 * Use these to test whether a particular lock is applied to a tuple
 */
static inline bool
HEAP_XMAX_IS_SHR_LOCKED(int16 infomask)
{
	return (infomask & HEAP_LOCK_MASK) == HEAP_XMAX_SHR_LOCK;
}

static inline bool
HEAP_XMAX_IS_EXCL_LOCKED(int16 infomask)
{
	return (infomask & HEAP_LOCK_MASK) == HEAP_XMAX_EXCL_LOCK;
}

static inline bool
HEAP_XMAX_IS_KEYSHR_LOCKED(int16 infomask)
{
	return (infomask & HEAP_LOCK_MASK) == HEAP_XMAX_KEYSHR_LOCK;
}
```

```sql
--Блокировки всех двух транзакций
SELECT * FROM locks_accounts WHERE pid in (1561,1562);
 pid  |   locktype    |    lockid     |       mode       | granted
------+---------------+---------------+------------------+---------
 1561 | relation      | accounts      | RowExclusiveLock | t
 1561 | transactionid | 830           | ExclusiveLock    | t
 1562 | relation      | accounts      | RowExclusiveLock | t
 1562 | transactionid | 830           | ShareLock        | f
 1562 | transactionid | 831           | ExclusiveLock    | t
 1562 | tuple         | accounts(0,1) | ExclusiveLock    | t
(6 rows)

--Очередь
SELECT pid, wait_event_type, wait_event, pg_blocking_pids(pid), left(query,50) AS query FROM pg_stat_activity WHERE pid IN (1561,1562);
 pid  | wait_event_type |  wait_event   | pg_blocking_pids |                       query
------+-----------------+---------------+------------------+----------------------------------------------------
 1562 | Lock            | transactionid | {1561}           | UPDATE accounts SET amount = amount+400 WHERE id=1
 1561 | Client          | ClientRead    | {}               | UPDATE accounts SET amount = amount+200 WHERE id=1
(2 rows)

--Статус 1ой транзакции
select pg_xact_status('830');
 pg_xact_status
----------------
 in progress
(1 row)
```

И так. Вторая транзакция хочет обновить строку ctid=(0,1), она видит в поле xmax номер транзакции 830, эта транзакция еще не завершена (статус in progress), следовательно, 2ой транзакции 831 нужно дождаться завершения 1ой транзакции 830 (у транзакции ExclusiveLock, а SharedLock не бывает), поэтому 2я транзакция захватывает исключительную тяжелую блокировку tuple на версию изменяемой строки accounts(0,1) в режиме ExclusiveLock, встает в очередь ожидания освобождения несовместимой блокировки (транзакция 830 ExclusiveLock, pid=1561) и запрашивает блокировку ее номера транзакции 830 в разделяемом режиме SharedLock, что равносильно ожиданию завершения транзакции.

```sql
--3ий сеанс. Начинаем третью транзакцию и получим id 3ей транзакции и 3-го сеанса

BEGIN;
SELECT pg_current_xact_id(), pg_backend_pid();
 pg_current_xact_id | pg_backend_pid
--------------------+----------------
                832 |           1563
(1 row)

-- Пытаемся обновить ту же строку.

UPDATE accounts SET amount = amount+600 WHERE id=1;

--Транзакция подвисает в ожидании блокировки:

-- Посмотрим блокировки (сеанс 4)

SELECT * FROM locks_accounts WHERE pid = 1563;
 pid  |   locktype    |    lockid     |       mode       | granted
------+---------------+---------------+------------------+---------
 1563 | relation      | accounts      | RowExclusiveLock | t
 1563 | transactionid | 832           | ExclusiveLock    | t
 1563 | tuple         | accounts(0,1) | ExclusiveLock    | f
(3 rows)

-- И что под капотом  (сеанс 4), а тут опять ничего не изменилось, все в том же состоянии, что и после 1ой транзакции, 3я транзакция, как и 2я, до сюда не дошла
SELECT * FROM heap_accounts;
 ctid  | t_ctid | t_xmin | t_xmax |                             raw_flags                             | combined_flags
-------+--------+--------+--------+-------------------------------------------------------------------+----------------
 (0,1) | (0,4)  |    824 |    830 | {HEAP_HASVARWIDTH,HEAP_XMIN_COMMITTED,HEAP_HOT_UPDATED}           | {}
 (0,2) | (0,2)  |    825 |      0 | {HEAP_HASVARWIDTH,HEAP_XMIN_COMMITTED,HEAP_XMAX_INVALID}          | {}
 (0,3) | (0,3)  |    826 |      0 | {HEAP_HASVARWIDTH,HEAP_XMIN_COMMITTED,HEAP_XMAX_INVALID}          | {}
 (0,4) | (0,4)  |    830 |      0 | {HEAP_HASVARWIDTH,HEAP_XMAX_INVALID,HEAP_UPDATED,HEAP_ONLY_TUPLE} | {}
(4 rows)

SELECT * FROM heap_accounts_det;
 ctid  | state  | t_ctid | xmin  | xmax | is_multi | is_upd_ver | keys_upd | lock_only | key_shr | exclusive | shared
-------+--------+--------+-------+------+----------+------------+----------+-----------+---------+-----------+--------
 (0,1) | normal | (0,4)  | 824 c | 830  |          |            |          |           |         |           |
 (0,2) | normal | (0,2)  | 825 c | 0 a  |          |            |          |           |         |           |
 (0,3) | normal | (0,3)  | 826 c | 0 a  |          |            |          |           |         |           |
 (0,4) | normal | (0,4)  | 830   | 0 a  |          | t          |          |           |         |           |
(4 rows)
```

Третья транзакция дошла только до первого шага. Она попыталась захватить блокировку версии строки и остановилась.

```sql
--Блокировки всех трех транзакций
SELECT * FROM locks_accounts WHERE pid = in (1561,1562,1563);
 pid  |   locktype    |    lockid     |       mode       | granted
------+---------------+---------------+------------------+---------
 1561 | relation      | accounts      | RowExclusiveLock | t
 1561 | transactionid | 830           | ExclusiveLock    | t
 1562 | relation      | accounts      | RowExclusiveLock | t
 1562 | transactionid | 830           | ShareLock        | f
 1562 | transactionid | 831           | ExclusiveLock    | t
 1562 | tuple         | accounts(0,1) | ExclusiveLock    | t
 1563 | relation      | accounts      | RowExclusiveLock | t
 1563 | transactionid | 832           | ExclusiveLock    | t
 1563 | tuple         | accounts(0,1) | ExclusiveLock    | f
(9 rows)

--Очередь
SELECT pid, wait_event_type, wait_event, pg_blocking_pids(pid), left(query,50) AS query FROM pg_stat_activity WHERE pid IN (1561,1562,1563);
 pid  | wait_event_type |  wait_event   | pg_blocking_pids |                       query
------+-----------------+---------------+------------------+----------------------------------------------------
 1562 | Lock            | transactionid | {1561}           | UPDATE accounts SET amount = amount+400 WHERE id=1;
 1563 | Lock            | tuple         | {1562}           | UPDATE accounts SET amount = amount+600 WHERE id=1;
 1561 | Client          | ClientRead    | {}               | UPDATE accounts SET amount = amount+200 WHERE id=1;
(3 rows)
```

Третья транзакция хочет обновить строку ctid=(0,1), обнаруживает в поле xmax транзакцию 830 процесса 1561, она еще не завершена, кроме того, завершения транзакции 830 (хочет SharedLock от нее) ждет процесс 1562, который в свю очередь наложил блокировку tuple на версию строки (0,1). Третья транзакция не сможет получить блокировку tuple на версию строки и встает в очередь, но ждать она будет не завершения 2ой транзакции, а с снятия блокировки tuple с версии строки accounts(0,1).

 Т.о. у нас сформировалась очередь: процесс 1562 ждет когда процесс 1561 завершит транзакцию 830, а процесс 1563 ждет когда процесс 1562 снимет блокировку tuple с версии строки (0,1).

```sql
-- 1ый сеанс. Успешно завершим транзакцию 
commit;
COMMIT

-- Посмотрим блокировки

SELECT * FROM locks_accounts WHERE pid = 1561;
 pid | locktype | lockid | mode | granted
-----+----------+--------+------+---------
(0 rows)

-- Блокировок нет, оно и логично, ведь 1я транзакция завершилась

-- Тем временем 2я транзакция выполнила обновление, посмотрим блокировки. Все то же самое что было ранее у первой транзакции.

SELECT * FROM locks_accounts WHERE pid = 1562;
 pid  |   locktype    |  lockid  |       mode       | granted
------+---------------+----------+------------------+---------
 1562 | relation      | accounts | RowExclusiveLock | t
 1562 | transactionid | 831      | ExclusiveLock    | t
(2 rows)

-- 3я транзакция висит. Посмотрим ее блокировки.

SELECT * FROM locks_accounts WHERE pid = 1563;
 pid  |   locktype    |  lockid  |       mode       | granted
------+---------------+----------+------------------+---------
 1563 | relation      | accounts | RowExclusiveLock | t
 1563 | transactionid | 831      | ShareLock        | f
 1563 | transactionid | 832      | ExclusiveLock    | t
(3 rows)

--Очередь
SELECT pid, wait_event_type, wait_event, pg_blocking_pids(pid), left(query,50) AS query FROM pg_stat_activity WHERE pid IN (1561,1562,1563);
 pid  | wait_event_type |  wait_event   | pg_blocking_pids |                       query
------+-----------------+---------------+------------------+----------------------------------------------------
 1562 | Client          | ClientRead    | {}               | UPDATE accounts SET amount = amount+400 WHERE id=1;
 1563 | Lock            | transactionid | {1562}           | UPDATE accounts SET amount = amount+600 WHERE id=1
 1561 | Client          | ClientRead    | {}               | commit;
(3 rows)

-- Посмотрим что под капотом  (сеанс 4)
SELECT * FROM heap_accounts;
 ctid  | t_ctid | t_xmin | t_xmax |                                         raw_flags                                         | combined_flags
-------+--------+--------+--------+-------------------------------------------------------------------------------------------+----------------
 (0,1) | (0,4)  |    824 |    830 | {HEAP_HASVARWIDTH,HEAP_XMIN_COMMITTED,HEAP_XMAX_COMMITTED,HEAP_HOT_UPDATED}               | {}
 (0,2) | (0,2)  |    825 |      0 | {HEAP_HASVARWIDTH,HEAP_XMIN_COMMITTED,HEAP_XMAX_INVALID}                                  | {}
 (0,3) | (0,3)  |    826 |      0 | {HEAP_HASVARWIDTH,HEAP_XMIN_COMMITTED,HEAP_XMAX_INVALID}                                  | {}
 (0,4) | (0,5)  |    830 |    831 | {HEAP_HASVARWIDTH,HEAP_XMIN_COMMITTED,HEAP_UPDATED,HEAP_HOT_UPDATED,HEAP_ONLY_TUPLE}      | {}
 (0,5) | (0,5)  |    831 |    831 | {HEAP_HASVARWIDTH,HEAP_XMAX_KEYSHR_LOCK,HEAP_XMAX_LOCK_ONLY,HEAP_UPDATED,HEAP_ONLY_TUPLE} | {}
(5 rows)

SELECT * FROM heap_accounts_det;
 ctid  | state  | t_ctid | xmin  | xmax  | is_multi | is_upd_ver | keys_upd | lock_only | key_shr | exclusive | shared
-------+--------+--------+-------+-------+----------+------------+----------+-----------+---------+-----------+--------
 (0,1) | normal | (0,4)  | 824 c | 830 c |          |            |          |           |         |           |
 (0,2) | normal | (0,2)  | 825 c | 0 a   |          |            |          |           |         |           |
 (0,3) | normal | (0,3)  | 826 c | 0 a   |          |            |          |           |         |           |
 (0,4) | normal | (0,5)  | 830 c | 831   |          | t          |          |           |         |           |
 (0,5) | normal | (0,5)  | 831   | 831   |          | t          |          | t         | t       |           |
(5 rows)
```

У старой версии строки ctid=(0,1) xmax закомитился, следовательно t_ctid=(0,4) указывает на новую версию строки, у нее xmin=830 и закомитен. Вторая транзакция пытается обновить эту новую версию строки ctid=(0,4), о чем свидетельствует ее номер в xmax=831 и создала еще одну обновленную версию строки ctid=(0,5), у которой xmin=831 и xmax=831 (а когда 1я транзакция обновляла, то xmax был равен нулю и был установлен флаг HEAP_XMAX_INVAL == xmax_aborted=true).

```sql

--Отступление от общего эксперимента

--У 3ей транзакции сейчас блокировки не такие, как были у 2ой транзакции, отсутствует блокировка типа tuple, что означает, что если бы после 3ей транзакции были бы еще транзакции, пытающиеся обновить эту же строку, то между ними началась бы гонка, кто раньше встал (проснулся), того и сапоги (строка).

--Ниже смоделирована ситуация из 5ти транзакций, пытающихся обновить одну и ту же строку
--Ни одна транзакция еще не завершена
SELECT * FROM locks_accounts WHERE pid in (1561,1562,1563,1564,1565);
 pid  |   locktype    |    lockid     |       mode       | granted
------+---------------+---------------+------------------+---------
 1561 | relation      | accounts      | RowExclusiveLock | t
 1561 | transactionid | 830           | ExclusiveLock    | t

 1562 | relation      | accounts      | RowExclusiveLock | t
 1562 | transactionid | 830           | ShareLock        | f
 1562 | transactionid | 831           | ExclusiveLock    | t
 1562 | tuple         | accounts(0,1) | ExclusiveLock    | t
 
 1563 | relation      | accounts      | RowExclusiveLock | t
 1563 | transactionid | 832           | ExclusiveLock    | t
 1563 | tuple         | accounts(0,1) | ExclusiveLock    | f
 
 1564 | relation      | accounts      | RowExclusiveLock | t
 1564 | transactionid | 833           | ExclusiveLock    | t
 1564 | tuple         | accounts(0,1) | ExclusiveLock    | f
 
 1565 | relation      | accounts      | RowExclusiveLock | t
 1565 | transactionid | 834           | ExclusiveLock    | t
 1565 | tuple         | accounts(0,1) | ExclusiveLock    | f
 
 SELECT pid, wait_event_type, wait_event, pg_blocking_pids(pid), left(query,50) AS query FROM pg_stat_activity WHERE pid IN (1561,1562,1563,1564,1565);
 pid  | wait_event_type |  wait_event   | pg_blocking_pids |                       query
------+-----------------+---------------+------------------+----------------------------------------------------
 1561 | Client          | ClientRead    | {}               | UPDATE accounts SET amount = amount+200 WHERE id=1
 1562 | Lock            | transactionid | {1561}           | UPDATE accounts SET amount = amount+400 WHERE id=1
 1563 | Lock            | tuple         | {1562}           | UPDATE accounts SET amount = amount+600 WHERE id=1
 1564 | Lock            | tuple         | {1562,1563}      | UPDATE accounts SET amount = amount+800 WHERE id=1
 1565 | Lock            | tuple         | {1562,1563,1564} | UPDATE accounts SET amount = amount+900 WHERE id=1
(5 rows)

--1я транзакция завершается комитом, выполнилось обновление во 2ой
SELECT * FROM locks_accounts WHERE pid in (1561,1562,1563,1564,1565);
 pid  |   locktype    |  lockid  |       mode       | granted
------+---------------+----------+------------------+---------
 1562 | relation      | accounts | RowExclusiveLock | t
 1562 | transactionid | 831      | ExclusiveLock    | t
 
 1563 | relation      | accounts | RowExclusiveLock | t
 1563 | transactionid | 831      | ShareLock        | f
 1563 | transactionid | 832      | ExclusiveLock    | t
 
 1564 | relation      | accounts | RowExclusiveLock | t
 1564 | transactionid | 831      | ShareLock        | f
 1564 | transactionid | 833      | ExclusiveLock    | t
 
 1565 | relation      | accounts | RowExclusiveLock | t
 1565 | transactionid | 831      | ShareLock        | f
 1565 | transactionid | 834      | ExclusiveLock    | t
(11 rows)

SELECT pid, wait_event_type, wait_event, pg_blocking_pids(pid), left(query,50) AS query FROM pg_stat_activity WHERE pid IN (1561,1562,1563,1564,1565);
 pid  | wait_event_type |  wait_event   | pg_blocking_pids |                       query
------+-----------------+---------------+------------------+----------------------------------------------------
 1561 | Client          | ClientRead    | {}               | commit;
 1562 | Client          | ClientRead    | {}               | UPDATE accounts SET amount = amount+400 WHERE id=1
 1563 | Lock            | transactionid | {1562}           | UPDATE accounts SET amount = amount+600 WHERE id=1
 1564 | Lock            | transactionid | {1562}           | UPDATE accounts SET amount = amount+800 WHERE id=1
 1565 | Lock            | transactionid | {1562}           | UPDATE accounts SET amount = amount+900 WHERE id=1
(5 rows)

--Вот она очередь, все ждут завершения 2ой транзакции (831 pid 1562). У меня получилась такая последовательность выполнения транзакций: 
--2ая коммит, обновление выполнилось в 3ей
--3я коммит, обновление выполнилось в 5ой
--5я коммит, обновление выполнилось в 4ой
--4я коммит
```

Вернемся к основному эксперименту и завершим его: откатим вторую и завершим третью транзакции

```sql
--Содержимое таблицы accounts
SELECT * FROM heap_accounts_det;
 ctid  | state  | t_ctid | xmin  | xmax  | is_multi | is_upd_ver | keys_upd | lock_only | key_shr | exclusive | shared
-------+--------+--------+-------+-------+----------+------------+----------+-----------+---------+-----------+--------
 (0,1) | normal | (0,4)  | 824 c | 830 c |          |            |          |           |         |           |
 (0,2) | normal | (0,2)  | 825 c | 0 a   |          |            |          |           |         |           |
 (0,3) | normal | (0,3)  | 826 c | 0 a   |          |            |          |           |         |           |
 (0,4) | normal | (0,6)  | 830 c | 832 c |          | t          |          |           |         |           |
 (0,5) | normal | (0,5)  | 831 a | 831   |          | t          |          | t         | t       |           |
 (0,6) | normal | (0,6)  | 832 c | 832   |          | t          |          | t         | t       |           |
(6 rows)

```

*****

Воспроизведем взаимоблокировку трех транзакций. И попробуем разобраться в ситуации постфактум, изучая журнал сообщений.

```sql
--Перезальем заново таблицу accounts
TRUNCATE TABLE accounts;
-- чтобы xmin были разные, каждая вставка отдельной командой
INSERT INTO accounts(id, client, amount) VALUES (1,'alice',100.00);
INSERT INTO accounts(id, client, amount) VALUES (2,'bob',200.00);
INSERT INTO accounts(id, client, amount) VALUES (3,'charlie',300.00);
-- сделаем select для простановки бита xmin committed
SELECT * FROM accounts;

--Зададим время ожидания блокировки, по истечении которого будет выполняться проверка состояния взаимоблокировки равное 10с.
ALTER SYSTEM SET deadlock_timeout TO 10000;
SELECT pg_reload_conf();

--1я сессия, 1я транзакция обновляет первую строку
BEGIN;
SELECT pg_current_xact_id(), pg_backend_pid();
 pg_current_xact_id | pg_backend_pid
--------------------+----------------
                979 |           1494
(1 row)

UPDATE accounts SET amount = amount+101 WHERE id=1;

--2я сессия, 2я транзакция обновляет вторую строку
BEGIN;
SELECT pg_current_xact_id(), pg_backend_pid();
 pg_current_xact_id | pg_backend_pid
--------------------+----------------
                980 |           1495
(1 row)

UPDATE accounts SET amount = amount+202 WHERE id=2;

--3я сессия, третья транзакция обновляет третью строку
BEGIN;
SELECT pg_current_xact_id(), pg_backend_pid();
 pg_current_xact_id | pg_backend_pid
--------------------+----------------
                981 |           1496
(1 row)

UPDATE accounts SET amount = amount+303 WHERE id=3;

--1я сессия, 1я транзакция попытается обновить 3ю строку, заблокированную 3ей транзакцией
UPDATE accounts SET amount = amount+111 WHERE id=3;
--транзакция подвисла

--2я сессия, 2я транзакция попытается обновить 1ю строку, заблокированную 1ой транзакцией
UPDATE accounts SET amount = amount+222 WHERE id=1;
--транзакция подвисла

--3я сессия, 3я транзакция попытается обновить 2ю строку, заблокированную 2ой транзакцией, тем самым замкнув круг
UPDATE accounts SET amount = amount+333 WHERE id=2;
--транзакция подвисла

--Подождем, пока PostgreSQL обнаружит взаимоблокировку (до 10с., задали в начале эксперимента)  
```

Возникает циклическое ожидание, которое никогда не завершится само по себе. PostgreSQL строит граф связей для выявления таких ситуаций и автоматически разрывает случайную блокировку после deadlock_timeout=10000ms. Ждем...

```sql
--Прошло 10с.

--1я транзакция: Висит

--2я транзакция
ERROR:  deadlock detected
DETAIL:  Process 1495 waits for ShareLock on transaction 979; blocked by process 1494.
Process 1494 waits for ShareLock on transaction 981; blocked by process 1496.
Process 1496 waits for ShareLock on transaction 980; blocked by process 1495.
HINT:  See server log for query details.
CONTEXT:  while updating tuple (0,1) in relation "accounts"

--3я транзакция
UPDATE 1
```

Посмотрим содержимое журнала.

```bash
sudo tail -n 30 /var/log/postgresql/postgresql-16-main.log
...
2025-02-02 14:48:38.160 MSK [1494] postgres@testlock LOG:  process 1494 still waiting for ShareLock on transaction 981 after 10000.549 ms
2025-02-02 14:48:38.160 MSK [1494] postgres@testlock DETAIL:  Process holding the lock: 1496. Wait queue: 1494.
2025-02-02 14:48:38.160 MSK [1494] postgres@testlock CONTEXT:  while updating tuple (0,3) in relation "accounts"
2025-02-02 14:48:38.160 MSK [1494] postgres@testlock STATEMENT:  UPDATE accounts SET amount = amount+111 WHERE id=3;

2025-02-02 14:48:45.348 MSK [1495] postgres@testlock LOG:  process 1495 detected deadlock while waiting for ShareLock on transaction 979 after 10000.327 ms
2025-02-02 14:48:45.348 MSK [1495] postgres@testlock DETAIL:  Process holding the lock: 1494. Wait queue: .
2025-02-02 14:48:45.348 MSK [1495] postgres@testlock CONTEXT:  while updating tuple (0,1) in relation "accounts"
2025-02-02 14:48:45.348 MSK [1495] postgres@testlock STATEMENT:  UPDATE accounts SET amount = amount+222 WHERE id=1;
2025-02-02 14:48:45.348 MSK [1495] postgres@testlock ERROR:  deadlock detected
2025-02-02 14:48:45.348 MSK [1495] postgres@testlock DETAIL:  Process 1495 waits for ShareLock on transaction 979; blocked by process 1494.
        Process 1494 waits for ShareLock on transaction 981; blocked by process 1496.
        Process 1496 waits for ShareLock on transaction 980; blocked by process 1495.
        Process 1495: UPDATE accounts SET amount = amount+222 WHERE id=1;
        Process 1494: UPDATE accounts SET amount = amount+111 WHERE id=3;
        Process 1496: UPDATE accounts SET amount = amount+333 WHERE id=2;
2025-02-02 14:48:45.348 MSK [1495] postgres@testlock HINT:  See server log for query details.
2025-02-02 14:48:45.348 MSK [1495] postgres@testlock CONTEXT:  while updating tuple (0,1) in relation "accounts"
2025-02-02 14:48:45.348 MSK [1495] postgres@testlock STATEMENT:  UPDATE accounts SET amount = amount+222 WHERE id=1;
...
```

Как видно из журнала, в нем отображены все события, связанные со взаимоблокировками. Мы видим, что, по истечению 10с., процесс 1495 (а это 2я сессия xact=980 pid=1495) обнаружил взаимоблокировку во время ожидания получения разделяемой блокировки ShareLock (фактически, это ожидание завершения транзакции) от транзакции 979. Процесс, удерживающий блокировку: 1494, очередь ожидания пуста. Все это произошло во время обновления версии строки (0,1) в таблице accounts, командой  UPDATE accounts SET amount = amount+222 WHERE id=1. Далее идет сама ошибка: Обнаружена взаимоблокировка. Ее описание: 
* Процесс 1495 ожидания получения разделяемой блокировки ShareLock от транзакции 979, заблокированной процессом 1494. 
* Процесс 1494 ожидания получения разделяемой блокировки ShareLock от транзакции 981, заблокированной процессом 1496. 
* Процесс 1496 ожидания получения разделяемой блокировки ShareLock от транзакции 980, заблокированной процессом 1495.

Круг замкнулся.

Аналогичное описание ошибки мы видели во 2ой сессии.

*****

Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга? 

Команда UPDATE блокирует строки по мере их обновления, на основании плана запроса. Она не блокирует все строки сразу (таблицу).

Такая ситуация может произойти, если одна команда будет обновлять строки таблицы в прямом порядке, а другая — в обратном. Также взаимоблокировка возможна, если для команд будут построены разные планы выполнения, например, одна будет читать таблицу последовательно, а другая — по индексу.

Воспроизвести такую ситуацию сложно, а вероятность столкнуться с ней в боевой среде ничтожна мала. 

Попробуем искусственно смоделировать ее при помощи курсоров.

```sql
--1-я сессия
BEGIN;
DECLARE cur_1 CURSOR FOR SELECT * FROM  accounts ORDER BY id ASC FOR UPDATE;

--2-я сессия
BEGIN;
DECLARE cur_2 CURSOR FOR SELECT * FROM  accounts ORDER BY id DESC FOR UPDATE;

--1-я сессия
FETCH cur_1;
 id | client | amount
----+--------+--------
  1 | alice  | 100.00
(1 row)

--2-я сессия
FETCH cur_2;
 id | client  | amount
----+---------+--------
  3 | charlie | 300.00
(1 row)

--1-я сессия
FETCH cur_1;
 id | client | amount
----+--------+--------
  2 | bob    | 200.00
(1 row)

--2-я сессия
FETCH cur_2;
--Висит, т.к. 2я строка заблокирована в 1ой сессии

--1-я сессия
FETCH cur_1;
--Висит, т.к. 3я строка заблокирована во 2ой сессии, круг замкнулся

--ждем 10с.

--1-я сессия
ERROR:  deadlock detected
DETAIL:  Process 1561 waits for ShareLock on transaction 985; blocked by process 1562.
Process 1562 waits for ShareLock on transaction 984; blocked by process 1561.
HINT:  See server log for query details.
CONTEXT:  while locking tuple (0,3) in relation "accounts"

--2-я сессия
--Отвисла
FETCH cur_2;
 id | client | amount
----+--------+--------
  2 | bob    | 200.00
(1 row)

--1-я сессия
rollback;

--2-я сессия
FETCH cur_2;
 id | client | amount
----+--------+--------
  1 | alice  | 100.00
(1 row)

FETCH cur_2;
 id | client | amount
----+--------+--------
(0 rows)

COMMIT;
```

Взаимоблокировка в журнале

```bash
sudo tail -n 30 /var/log/postgresql/postgresql-16-main.log
...
2025-02-02 16:33:15.940 MSK [1562] postgres@testlock LOG:  process 1562 still waiting for ShareLock on transaction 984 after 10000.821 ms
2025-02-02 16:33:15.940 MSK [1562] postgres@testlock DETAIL:  Process holding the lock: 1561. Wait queue: 1562.
2025-02-02 16:33:15.940 MSK [1562] postgres@testlock CONTEXT:  while locking tuple (0,2) in relation "accounts"
2025-02-02 16:33:15.940 MSK [1562] postgres@testlock STATEMENT:  FETCH cur_2;
2025-02-02 16:34:47.531 MSK [1561] postgres@testlock LOG:  process 1561 detected deadlock while waiting for ShareLock on transaction 985 after 10000.657 ms
2025-02-02 16:34:47.531 MSK [1561] postgres@testlock DETAIL:  Process holding the lock: 1562. Wait queue: .
2025-02-02 16:34:47.531 MSK [1561] postgres@testlock CONTEXT:  while locking tuple (0,3) in relation "accounts"
2025-02-02 16:34:47.531 MSK [1561] postgres@testlock STATEMENT:  FETCH cur_1;
2025-02-02 16:34:47.531 MSK [1561] postgres@testlock ERROR:  deadlock detected
2025-02-02 16:34:47.531 MSK [1561] postgres@testlock DETAIL:  Process 1561 waits for ShareLock on transaction 985; blocked by process 1562.
        Process 1562 waits for ShareLock on transaction 984; blocked by process 1561.
        Process 1561: FETCH cur_1;
        Process 1562: FETCH cur_2;
2025-02-02 16:34:47.531 MSK [1561] postgres@testlock HINT:  See server log for query details.
2025-02-02 16:34:47.531 MSK [1561] postgres@testlock CONTEXT:  while locking tuple (0,3) in relation "accounts"
2025-02-02 16:34:47.531 MSK [1561] postgres@testlock STATEMENT:  FETCH cur_1;
2025-02-02 16:34:47.531 MSK [1562] postgres@testlock LOG:  process 1562 acquired ShareLock on transaction 984 after 101592.401 ms
2025-02-02 16:34:47.531 MSK [1562] postgres@testlock CONTEXT:  while locking tuple (0,2) in relation "accounts"
2025-02-02 16:34:47.531 MSK [1562] postgres@testlock STATEMENT:  FETCH cur_2;
...
```


